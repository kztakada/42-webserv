# keep-alive（Persistent Connections）仕様

このドキュメントは、本プロジェクト（webserv）の HTTP/1.0 / HTTP/1.1 における
**keep-alive（持続接続）**の挙動と、エラー時に接続を維持するか切断するかの方針を
「現状の実装」に合わせて整理したものです。

## ゴール

- 1つの TCP コネクション上で複数リクエスト/レスポンスを処理できること
- telnet 等での手入力（断片的な入力）でも、
	- リクエストが完成するまでは応答しない（無限エラー応答ループを避ける）
	- 同期が保てる場合は keep-alive を維持する
- エラー時の切断/維持が、HTTPとして自然かつ安全（ストリーム同期）であること

## 用語

- **ストリーム同期**：同一接続上で、次のリクエスト開始位置が曖昧にならないこと。
	- 受信途中のパースエラーや未完了状態で応答してしまうと、以後のバイト列を
		どこから次のリクエストとして扱うべきか分からなくなりやすい。

## keep-alive の基本判定

### HTTPバージョンと `Connection`

- HTTP/1.1：デフォルトで keep-alive（持続接続）
	- `Connection: close` が明示されている場合は切断方向
- HTTP/1.0：デフォルトで close（切断）
	- `Connection: keep-alive` が明示されている場合は維持方向

この判定は、リクエストパーサが `HttpRequest::shouldKeepAlive()` として保持します。

### レスポンス側の最終判断（エンコーダ）

レスポンスのフレーミング（例：HTTP/1.0のclose-delimited等）によっては、
keep-alive したくても **プロトコル上/実装上 close が必要**な場合があります。
その場合、レスポンスエンコーダが close を要求します。

## セッション状態遷移（概要）

HTTPセッションは概ね以下の流れで動きます。

1. 受信（リクエストパース）
2. 処理（ルーティング / CGI / 静的返却など）
3. 送信（レスポンスエンコード & flush）
4. 完了後、keep-alive 可能なら次の受信へ戻る / close なら切断

重要な点：
- keep-alive で次のリクエストを受けるためには、送信完了後に read 監視へ戻る必要があります。

## 「応答後に接続を切断する」条件

本プロジェクトの方針は、ステータスコードの大小で一律に決めず、
**ストリーム同期が保証できるか**で決めます。

### 1) 同期不能のときは close（安全側）

次の条件に当てはまる場合は、**応答後に切断**します。

- リクエストが **parse complete していない**（受信途中）
- リクエストが **parse error** になっている

この場合、レスポンスに `Connection: close` を付け、
セッションも close フラグを立てます。

理由：
- 受信途中の不正入力に対して応答しても、その後に届くバイト列が
	「次のリクエスト」なのか「壊れたリクエストの残骸」なのか分からず、
	無限エラー応答や誤解釈に繋がりやすい。

### 2) 同期可能のときは keep-alive 維持が基本

- リクエストが parse complete しており、parse error でもない
- レスポンスエンコーダが close を要求しない

上記のときは、4xx/5xx を含めて原則 keep-alive 維持が可能です。

## 具体例

### 400（Bad Request）

- **受信途中の 400（パースエラー/未完了）**：応答後 close
	- 例：ヘッダ構文違反、CRLFの扱いで「空リクエスト」と判断、等
- **parse complete 後にアプリ都合で 400**：原則 keep-alive 可能
	- 例：ルーティング段階での検証失敗など（※どの経路で 400 になるかに依存）

※「400は必ずclose」という固定ルールではありません。

### 404 / 405

通常はリクエストが確定（parse complete）しているため、
原則 keep-alive 維持が可能です（エンコーダ都合を除く）。

### 413（Payload Too Large）

**重要：413は parse error にせず、ストリーム同期を保って keep-alive 可能にする**
という方針です。

- `max_body_bytes`（client_max_body_size 等）超過を検知したら
	- `payload_too_large` を立てる
	- ボディは BodyStore 等に書き込まず、**最後まで読み飛ばして（drain）** parse complete に到達する
- 上位層で `payload_too_large` を検出して 413 応答を作る
- 応答後は原則 keep-alive 維持（エンコーダ都合を除く）

理由：
- 413は「リクエストが大きすぎる」だけで、リクエスト境界が壊れているとは限らない。
- ただし keep-alive を維持するには、次リクエストの先頭位置を守るために
	**当該リクエストのボディを最後まで読み切る（読み飛ばす）**必要がある。

### 5xx（内部エラー）

- 内部エラー（500等）は、リクエストが parse complete している前提なら
	原則 keep-alive 維持が可能です。
- close が必要な場合（HTTP/1.0 close-delimited など）は、エンコーダが判断します。

## telnet 等の「断片入力」への挙動

### リクエスト完成まで応答しない

- リクエストライン＋ヘッダ終端（CRLF CRLF）まで到達しない限り、
	原則としてレスポンスを返しません。
- これにより「未完了入力に対する無限エラー応答」を防ぎます。

### request-line 前の空行（CRLF）

- request-line の前に空行が混ざるケースを考慮し、**先頭の空行は1回だけ無視**します。
- ただし、連続空行を無制限に許容すると、空行だけ送られ続けていつまでも進まないため、
	**2回目以降の空行は不正（400）**として扱います。
	- この 400 は「同期不能（空リク）」側なので、応答後 close になるのが基本です。

## テスト指針（現状）

- 1コネクションでの連続 GET が成功する（keep-alive の基本）
- CRLFだけ（未完了入力）では応答しない
- CRLFが連続して空リクと判断されると 400（かつ close）
- 413後も次のリクエストを同一接続で処理できる（drain が効いて同期が保てる）

## 注意事項

- 「どのステータスで必ず切断するか」ではなく、
	**そのエラーが “同期不能” か “同期可能” か**が最重要です。
- 将来、パーサやルーティングのエラー分類を増やす場合も、
	「同期可能なエラーは keep-alive を優先、同期不能は close」を基準に設計します。
